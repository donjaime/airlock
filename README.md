# airlock

A lightweight CLI and set of credential management patterns to create **project-scoped, persistent container sandboxes** for local development — isolating your system from untrusted code, supply-chain attacks, and agent-driven automation.

`airlock` was inspired by the ease of use and developer convenience of **Fedora Toolbx (aka Toolbox)** for mutable, local dev workflows, but with 2 additional goals:
1. **Container isolation against 3rd part dependency supply-chain attacks**
2. **Host file and credential separation for agentic tools to more safely operate in YOLO mode**


## What you get
- **Container isolation** to mitigate most supply-chain attacks in npm and pip as well as provide some safety against a YOLO agent destroying your system or accessing secrets
- **An agent-agnostic workflow**. You can use any CLI agent
- **A human-friendly workflow**: you can just `enter` and work
- **Persistent state where it matters**: project-scoped HOME + installation cache
- **Patterns for identity and credential management**: project-scoped or shared secrets, ssh and gpg credentials - again to limit what can be done inside the container
- **Podman-rootless first** (though Docker is supported) to ensure containers don't have host sudo 

## How it works
`airlock` is a CLI tool for starting and entering container dev environments, and some workflow patterns around managing identities and credentials and supplying them into these environments.

Your host computer is where persistent files, project source, secrets and credentials live.

Your development environment is an interactive base container that you shell into and mutate. You develop and install runtime dependencies like a normal developer box (and like Fedora toolbox) once inside the container.

State is only persisted on disk beyond the lifetime of the container via mounts mapped in from your host.
1. **A project scoped HOME directory** - This defaults to `<Project Dir>/.airlock/home` and is mapped to `/home/agent` inside the container.
2. **A project scoped CACHE directory** - A place for package manager output, local installs or data files (or other runtime mutations) that are not considered a part of your repository. This defaults to `<Project Dir>/.airlock/cache` and is mapped to `/home/agent/.cache` inside the container.
3. **The project working directory** - Typically this is the root your git repo/version controlled source and is mapped to `/workspace` (or your configured workdir) inside the container.

We keep the CLI tool very simple, and push most of the setup into an `airlock.yaml` that can be generated by

> Note: The default mount location for the cache folder under the home folder might mean we make an empty folder at `.airlock/home/.cache` to create the mount point. The contents inside the conainer will point to `.airlock/cache`

## `airlock.yaml` (project configuration)

`airlock.yaml` is a small, project-scoped config file that tells Airlock:

* which container image to run (or how to build it),
* what to mount into the sandbox,
* what home/cache directories to use (defaults to `.airlock/home` and `.airlock/cache`),
* what command to run when entering the sandbox.

Airlock will **create and persist** project state under `.airlock/` by default.

### Example `airlock.yaml`

```yaml
# airlock.yaml
version: 1

# The sandbox container image to run.
# You can either point at a prebuilt image OR provide a build section.
image: ghcr.io/your-org/airlock-dev:latest

# Optional: Build an image locally instead of pulling one.
# If build is set, Airlock will build and tag an image for this project.
# build:
#   context: .
#   dockerfile: .airlock/Containerfile
#   tag: airlock-myproject:dev

# Project-scoped persistent directories (defaults shown).
# These paths are on the host, relative to the repo root.
home: .airlock/home
cache: .airlock/cache

# Mounts bind host paths into the container.
# Keep this minimal and explicit. Identities are typically symlinked
# into `home` before entering (see "Identities" section).
mounts:
  # Mount the repo into the container (read/write).
  - source: .
    target: /workspace
    mode: rw

  # Optional: share a host-level package cache (speeds up installs).
  # - source: ~/.cache/pip
  #   target: /host-cache/pip
  #   mode: rw

# Environment variables to set inside the container.
env:
  # Standard: keep tools pointed at the mounted workspace.
  WORKSPACE: /workspace

  # Example: make git use the workspace by default.
  # GIT_WORK_TREE: /workspace
  
  # Additional env vars can be passed in via .airlock/airlock.local.yaml
  # You can pass local-only secrets via that file

# What command to run when you "enter" the sandbox.
# Defaults to an interactive shell if omitted.
entrypoint:
  cmd: ["/bin/bash", "-l"]

# Where Airlock should set the container working directory at startup.
workdir: /workspace

ports:
  - host: 3000
    container: 3000
  - host: 54321
    container: 5432

# Optional: runtime selection or arguments (kept intentionally simple).
runtime:
  engine: podman   # or "docker" (depending on what your implementation supports)
  # extra_args:
  #   - "--network=host"
```


---

## What each field means

### `version`

A config version for forward compatibility.

* `version: 1` is the current format.

### `image`

The container image Airlock should run.

* Example: `ghcr.io/your-org/airlock-dev:latest`
* Use this when you have a standard base image for your team/org.

### `build` (optional)

If present, Airlock builds an image for this project instead of pulling `image`.

* `context`: build context directory (usually `.`)
* `dockerfile`: path to Dockerfile/Containerfile
* `tag`: local image tag to build to

Use `build` when:

* you want project-specific tooling baked into the image,
* you’re iterating on the container environment.

### `home` and `cache`

Host paths for **project-scoped persistence**.

* `home`: mounted as `$HOME` in the container (or otherwise used as the container user’s home).
* `cache`: a persistent cache directory intended for package managers and build caches.

Defaults:

* `home: .airlock/home`
* `cache: .airlock/cache`

You can point these at a shared location if you *want* cross-project reuse, e.g.:

```yaml
home: ~/.airlock/home/myproject
cache: ~/.airlock/cache/myproject
```

### `mounts`

A list of explicit host→container mounts.

Each mount has:

* `source`: path on the host (relative to repo root is allowed)
* `target`: path inside the container
* `mode`: `rw` or `ro`

Recommended minimum mount:

* mount the repo to `/workspace` as `rw`

Example minimal mounts:

```yaml
mounts:
  - source: .
    target: /workspace
    mode: rw
```

### `env`

Environment variables to set inside the container.

Common use cases:

* point tools at `/workspace`,
* configure caches (prefer `.airlock/cache`),
* set language/toolchain env vars.

### `entrypoint`

What runs when you do `airlock enter`.

* `cmd` is an array (exec form), e.g. `["/bin/bash","-l"]`
* If omitted, Airlock should default to a login shell.

### `workdir`

The working directory inside the container after it starts.

Typically:

* `workdir: /workspace`

### `runtime`

Keeps runtime selection simple.

* `engine`: `podman` or `docker` (depending on your implementation)
* `extra_args` (optional): passthrough flags to the runtime (keep this sparse)


### `ports`

The `ports` field is a list of host ↔ container port mappings.

Each entry has:

* `host`: port number on the host machine
* `container`: port number inside the container

```yaml
ports:
  - host: <host-port>
    container: <container-port>
```

You can define multiple services on the same container. For example:

```yaml
ports:
  - host: 3000
    container: 3000
  - host: 6006
    container: 6006   # Storybook
  - host: 9229
    container: 9229   # Node inspector
```

Under the hood, Airlock translates `ports` into the container runtime’s native flags:
* Podman: `-p host:container`
* Docker: `-p host:container`



---


## Install

### Build from source

```bash
git clone https://github.com/donjaime/airlock
cd airlock
go build -o airlock ./cmd/airlock
sudo mv airlock /usr/local/bin/
```

## Commands

- `airlock init`  
  Creates `airlock.yaml` (if missing), ensures `.airlock/` state dirs, and updates `.gitignore`.

- `airlock up`  
  Builds container image (if configured) + creates container + ensures state dirs exist.

- `airlock enter`  
  Enters the container with `bash -l`.

- `airlock exec -- <cmd...>`  
  Runs a command inside the container.

- `airlock down`  
  Stops and removes the container (keeps `.airlock` state dirs).

- `airlock info`  
  Prints detected engine, paths, and config.

- `airlock version`  
  Prints version.



## Typical workflow

1. Create config + state dirs:


```bash
airlock init
```

This creates:

- `airlock.yaml` (only if missing)

- `./.airlock/home` and `./.airlock/cache`

- ensures `.gitignore` ignores `.airlock/`

Your `airlock.yaml` is typically safe to check in to version control if it only contains stable relative configuration.
It must never contain secrets directly.

If you want to have non-version controlled local configuration, you can also add a `./.airlock/airlock.local.yaml` and any properties there will merge with the default `airlock.yaml`.
This is often a convenient way to pass in local-only tokens that typically would be set as environment variables.

2. Run:


```bash
airlock up
airlock enter
```

You should land in an interactive shell inside the container at `/workspace` (or your configured workdir).


## Identities & Credentials
Airlock intentionally does **not** manage identities internally.
Instead, identities live in a **shared host directory**, and each project explicitly **symlinks only what it needs** into its project-scoped home (`.airlock/home`) *before* entering the sandbox.

This keeps the “secret materialization step” on the host, makes access easy to audit (`ls -la .airlock/home`), and avoids hidden identity managers inside the sandbox.

### Principles
- **Never symlink whole identity directories** (e.g. don’t link all of `~/.ssh`).
- Prefer **per-project** or **per-org** identities (keys/configs/tokens) over personal “everything” identities. You can generate an identity for a CLI agent (like Claude Code) and only offer that identity inside the container.
- Keep secrets **outside the repo**, and symlink them into `.airlock/home`.
- Treat `.airlock/home` as persistent: if a tool writes tokens/caches there, they will remain until you remove them.


### Identity store location (host)

You can absolutely symlink identities surgically from your host's home dir. But to enforce some stricter separation, we recommend creating separate credentials for ssh, gpg, etc... and storing curated identities under:

```
~/.config/airlock/identities/
```

Example layout:

```
~/.config/airlock/identities/
  work-foo/
    .ssh/
      id_ed25519_work_foo
      id_ed25519_work_foo.pub
      config
      known_hosts
    .aws/
      config
      credentials
    gh_token
```

Each subdirectory represents a **coherent identity profile** (work, client, org, etc.).

---

## Linking identities into a project (recommended pattern)

Airlock mounts `.airlock/home` as `$HOME` inside the container.
Before entering, symlink **only the required files** from the shared identity store.

### Example: SSH (single key, minimal config)

```bash
mkdir -p .airlock/home/.ssh
chmod 700 .airlock/home/.ssh

ln -sf ~/.config/airlock/identities/work-foo/.ssh/id_ed25519_work_foo \
       .airlock/home/.ssh/id_ed25519_work_foo

ln -sf ~/.config/airlock/identities/work-foo/.ssh/config \
       .airlock/home/.ssh/config

ln -sf ~/.config/airlock/identities/work-foo/.ssh/known_hosts \
       .airlock/home/.ssh/known_hosts 2>/dev/null || true
```

**Do not** symlink your entire `~/.ssh` directory.

---

## Example: Git identity (project-scoped)

```bash
ln -sf ~/.config/airlock/identities/work-foo/.gitconfig \
       .airlock/home/.gitconfig
```

---

## Example: GitHub CLI token (least privilege)

```bash
mkdir -p .airlock/home/.secrets
chmod 700 .airlock/home/.secrets

ln -sf ~/.config/airlock/identities/work-foo/gh_token \
       .airlock/home/.secrets/gh_token
```

Inside the container:

```bash
export GH_TOKEN="$(cat ~/.secrets/gh_token)"
gh auth status
```

---

## Example: AWS credentials (no global `~/.aws`)

```bash
mkdir -p .airlock/home/.aws
chmod 700 .airlock/home/.aws

ln -sf ~/.config/airlock/identities/work-foo/.aws/config \
       .airlock/home/.aws/config

ln -sf ~/.config/airlock/identities/work-foo/.aws/credentials \
       .airlock/home/.aws/credentials
```

---

## Auditing identity exposure

Before entering the sandbox, you should be able to answer:

> “Exactly which identity files can this container see?”

Check with:

```bash
find .airlock/home -type l -print -exec readlink {} \;
```

If it’s too much, remove symlinks and try again.

---

## Persistence and lifecycle notes

* `.airlock/home` is **project-scoped and persistent**.
* Identities remain linked until you remove the symlinks.
* Tools may write auth caches or tokens into `$HOME`.

Best practices:

* keep identity **sources** in `~/.config/airlock/identities/`
* treat `.airlock/` as **safe to delete and recreate** (modulo recreating runtime mutations and installations)
* prefer `.airlock/cache` for tool caches when configurable


> **If it’s in `.airlock/home` (or one of the mounted folders), the container can see it.
> If it’s not, it can’t.**

---


## Auditing what the sandbox can see

Before entering:

```bash
find .airlock/home -maxdepth 3 -type l -print -exec readlink {} \;
```

If you accidentally linked too much, remove it:

```bash
rm .airlock/home/.ssh   # or remove specific symlinks
```

---

## Notes on persistence and safety

- `.airlock/home` is designed to persist across container rebuilds. That’s great for dev convenience, but it means:

  - tools may write auth caches or tokens into `$HOME`;

  - your symlinks remain until removed.

- For caches and tool state, prefer `.airlock/cache` (if your airlock implementation mounts it), and configure tools to store caches there when possible.

- Keep curated identity material in a shared host folder (like `~/.airlock/identities/…`) rather than sprinkling secrets around your normal `~`.


## Secrets and API tokens

**Do not commit secrets.** `.airlock/` is ignored by default.

### Recommended:

Either add them to `.airlock/airlock.local.yaml` under `env` (see yaml section above explaining the yaml format)

OR explicitly forward ambient environment vars into the container when you enter it.
```bash
export ANTHROPIC_API_KEY="..."
airlock enter -e "ANTHROPIC_API_KEY"
```

## Claude Code (optional)

If installed during the container build:

```bash
claude --help
```

If it isn’t installed (upstream changes happen), install manually when inside the container:

```bash
npm install -g @anthropic-ai/claude-code
```

## License

MIT
